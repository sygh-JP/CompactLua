///////////////////////////////////////////////////////////////////////////////

LuabindLib について

///////////////////////////////////////////////////////////////////////////////

【概要】

Luabind の Visual C++ (x86, x64, ARM) 用スタティック ライブラリ（のプロジェクト）です。
Luabind はソースコードのみの提供で、ビルドされたライブラリの形で提供されていないので、
使用者が自分でコンパイルする必要があります。
一番簡単なのは luabind/src/*.cpp を VC++ プロジェクトに追加して、
ユーザープログラムと一緒にコンパイルすることですが、毎回追加するのが面倒だし、
Luabind が含まれているとリビルドにかかる時間が急激に増加します。
スタティック ライブラリにしておけば、Luabind ソースの部分に関してはコンパイル時間を削減でき、
また DLL より作成が簡単なので便利です。
ただし、スタティック ライブラリ自体のコンパイルにはプリコンパイル済みヘッダーが使えない、
クライアント プログラムのコンパイラごとにバイナリを作成する必要がある、などの欠点もあります。
さらに、Luabind は C++ テンプレート ベースのためヘッダーのほうが実装量が多く、
ライブラリを作成したとしても Luabind を使わない場合と比較してコンパイル時間は
かなり増大してしまいます。
プリコンパイル済みヘッダーを使う、Luabind を使用するソース ファイルは完全分離する、などの
コンパイル時間を短縮する工夫は依然として必要となります。

なお、公式の Luabind 0.9.1 は Lua 5 以上、Boost 1.30.0 以上が必須とのことですが、
Lua 5.2 以降、Boost 1.57.0 以降に対応していません。
これらに対応するためには、一部のコードを修正する必要があります。

Luabind 0.7 では "lauxlib.h" が明示的にインクルードされていなかったために
コンパイル時に "LUA_NOREF" シンボルが見つからずエラーになっていましたが、
Luabind 0.8 以降では修正されている模様です。

Luabind は C++ テンプレートを使いまくっているので、作成されるライブラリの
バイナリは結構大きくなります（特に最適化の行なわれる Release ビルドで顕著）。

ちなみに、luabind 名前空間は using namespace しないほうが無難です。
最低でもブロック内 using 宣言等にとどめておいたほうがよいです。

///////////////////////////////////////////////////////////////////////////////

【WinRT 対応】

Windows ストア アプリ版では Windows API および CRT 関数の使用に制約がかかるため、
デスクトップ版 Lua の全機能をサポートすることはできません。

https://msdn.microsoft.com/library/windows/apps/br205757.aspx
https://msdn.microsoft.com/library/windows/apps/jj606124.aspx
https://msdn.microsoft.com/ja-jp/library/hh972425.aspx

特に、ストア アプリでは isleadbyte() などに代表される、ANSI マルチバイト文字列
（日本語版での CP-932 Shift_JIS、英語版での Windows-1252 西ヨーロッパ言語など）用の
CRT 関数が使用できなくなっています。
ストア アプリで Lua スクリプトを使う場合は UTF-8 を使用します。
なお、ストア アプリの GUI でやりとりされる文字はすべて UTF-16 のワイド文字なので、
GUI と Lua スクリプト間で相互に文字・文字列をやりとりするためには UTF-16 <==> UTF-8 の変換が
必要になります。
また、ストア アプリでは GetModuleFileNameA() / GetModuleFileNameW() も使えません。
Lua ビルド オプションの API 文字セットは一律 Unicode 文字セットとしていますが、
Lua 全体でワイド文字列用 API を内部で使うように修正しているわけではありません。

///////////////////////////////////////////////////////////////////////////////

【注意事項】

LuabindLib のビルド後に生成されるスタティック リンク ライブラリ（*.lib ファイル）は、
既定で CRT マルチスレッド DLL および Unicode ビルド構成となります。
誤って異なる構成の EXE や DLL に対してリンクすると実行時エラーが発生します。
LuabindLib を利用する側のプロジェクト設定にも注意が必要です。

なお、Lua, Luabind ともに、ライブラリ自体をソースコード レベルでデバッグしたい場合は、
[構成プロパティ]→[C/C++]→[全般]→[デバッグ情報の形式]にて、
デバッグ情報を有効（*.pdb 有り）にしてビルドしてください。
Win32 Debug ビルドでは「エディット コンティニュー用プログラム データベース (/ZI)」、
それ以外のビルドでは「プログラム データベース (/Zi)」とするのが通例です。
pdb ファイルはスタティック ライブラリの場合 lib ファイルと同じ場所に配置しておくと、
VC++ のリンカーが勝手に探索してくれます。
ダイナミック ライブラリの場合は dll ファイルと同じ場所に配置しておきます。

また、Luabind 0.9.1 を使うとき、グローバル変数あるいは名前空間レベルの変数などの初期化が
CRT の初期化よりも先に実行されることがあるようで、そのせいで MFC アプリケーションなどの
終了時に IDE 出力ウィンドウにメモリーリークが報告される場合があります。
Luabind を使うコードを DLL に隔離して、遅延ロードすることで対処してください。
VC++ 6.0 以降は LoadLibrary() を使わずとも、リンカー オプションで遅延ロードさせる
ことが可能になっています。

なお、「Windows ストア アプリのサポート」を「はい」に設定したスタティック ライブラリ
（/ZW コンパイル オプション）は、実は Windows 8.x/10 上であれば
ストア アプリでもデスクトップ アプリでも共通して利用可能ですが、DLL の場合は
ローダーのメカニズムがストア アプリとデスクトップ アプリとで異なるらしく、
デスクトップ アプリにリンクしてしまうと起動時に 0xc000a200 のランタイム エラーが
発生してしまうようです。


コード利用時のライセンスは、Boost, Lua, Luabind それぞれのライセンスに従ってください。
また、コードの利用は自己責任でお願いします。
仮に損害が発生したとしても、当方は一切の責任を負いません。

///////////////////////////////////////////////////////////////////////////////

【参考】

・Boost C++ Libraries 公式サイト
http://www.boost.org/

・Lua 公式サイト
http://www.lua.org/
http://luabinaries.sourceforge.net/download.html

・Luabind 公式サイト
http://www.rasterbar.com/products/luabind.html


2017-04-01, sygh.
